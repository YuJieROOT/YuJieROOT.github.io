{"posts":[{"title":"穷竭搜索","content":"核心思想 1.深度优先搜索（DFS）：从某个状态开始，不断转移，直至无法转移，回退到前一步，再继续转移到其他状态，直到找到最终解。通常采用递归函数或者栈（Stack）来实现。 2.宽度优先搜索（BFS）：从初始状态开始，总是先搜索至距离初始状态近的状态。每个状态都只经过一次，因此复杂度为O(状态数*转移方式数)。通常采用循环或队列（Queue）实现。 方向准备： int xx[]={0,0,1,-1}, yy[]={1,-1,0,0}; for(int i=0;i&lt;4;i++) { int dx = x.front()+xx[i]; int dy = y.front()+yy[i]; } DFS 一共有几条路径 例： 1.八皇后 #include&lt;bits/stdc++.h&gt; using namespace std; int n,cnt; bool a[20];//列 bool b[20];//右斜 bool c[40];//左斜 int s[20]; void pr() { for(int i=1;i&lt;=n;i++) { cout&lt;&lt;s[i]&lt;&lt;' '; } cout&lt;&lt;endl; } void dfs(int x) { if(x&gt;n) { cnt++; pr(); } else { for(int i=1;i&lt;=n;i++)//行 { if(!a[i]&amp;&amp;!b[x-i+n]&amp;&amp;!c[x+i]) { a[i]=1; b[x-i+n]=1; c[x+i]=1; s[x]=i; dfs(x+1); a[i]=0; b[x-i+n]=0; c[x+i]=0; } } } } int main() { cin&gt;&gt;n; dfs(1); cout&lt;&lt;cnt; } 2.迷宫 题目背景 给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。 输入格式 第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,t,sx,sy,fx,fy,cnt; bool vis[10][10]; bool mp[10][10]; int x[]={0,0,1,-1}; int y[]={1,-1,0,0}; void dfs(int sx,int sy) { if(sx==fx&amp;&amp;sy==fy) { cnt++; return; } for(int i=0;i&lt;4;i++) { int dx = sx + x[i]; int dy = sy + y[i]; if(!vis[dx][dy]&amp;&amp;dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m&amp;&amp;!mp[dx][dy]) { vis[dx][dy]=1; dfs(dx,dy); vis[dx][dy]=0; } } } int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy; while(t--) { int x,y; cin&gt;&gt;x&gt;&gt;y; mp[x][y]=1; } vis[sx][sy]=1; dfs(sx,sy); cout&lt;&lt;cnt; } BFS 一个点到另一个点需要走几步 ","link":"https://yujieroot.github.io/post/sou-suo"},{"title":"STL","content":"priority_queue 1.头文件 #include&lt;queue&gt; #include&lt;algorithm&gt; 2、定义 priority_queue&lt;Type, Container, Functional&gt; Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a; //大根 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; s; //小根 如果不写后两个参数，那么容器默认用的是vector，比较方式默认用operator&lt;，也就是优先队列是大顶堆，队头元素最大。 万能库 #include&lt;bits/stdc++.h&gt; ","link":"https://yujieroot.github.io/post/rong-qi-shi-yong"},{"title":"细节","content":"一，精度问题 当题目中出现需要有高精度的输出时： 定义变量：long double scanf : %Lf pirntf : %.Lf 二，输入问题 当需要一直输入时： while(scanf()!=-1){} 三，输出问题 四，定义变量问题 不加 long long 见祖宗 数组定义在main外可以开大 ","link":"https://yujieroot.github.io/post/za"},{"title":"十大经典排序算法","content":"​ 1.冒泡排序 ​ 2.选择排序 ​ 3.插入排序 ​ //若无限制可随意用 ​ 4.希尔排序 ​ 5.归并排序 ​ 6.快速排序 ​ 7.堆排序 ​ 8 .计数排序 ​ 9.桶排序 ​ 10.基数排序 时间复杂度: 平方阶O(n2)排序，各类简单排序：插入、选择和冒泡排序； 线性对数阶O(nlog2n)排序：快速排序、堆排序和归并排序； O(n+§)排序，§是介于0和1之间的常数：希尔排序； 线性阶O(n)排序：基数排序，桶、箱排序； 1.冒泡排序 1.1算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2代码实现 for(int i=0;i&lt;len-1;i++) { for(int j=0;j&lt;len-1-i;j++) { if(a[j]&gt;a[j+1]) { swap(a[i],a[j]); } } } 2.选择排序 2.1算法描述 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.2代码实现 for(int i=0;i&lt;len-1;i++) { int max=i; for(int j=i+1;j&lt;len;j++) { if(a[max]&lt;a[j]) { max=j; } } temp=arr[i]; arr[i]=a[max]; a[max]=temp; } 2.3算法分析 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 3、插入排序 3.1算法描述 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 代码实现 for(int i=1;i&lt;len;i++) { preIndex=i-1; current=a[i]; while(preIndex&gt;=0;&amp;&amp;a[preIndex]&gt;a[i]) { a[i]=a[preIndex]; preIndex--; }//a[i]永远是preIndex及其以前数据中最大的 a[preIndex+1]=current; } 3.3 算法分析 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 4、希尔排序（Shell Sort） 4.1 算法描述 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 代码实现 void shell_Sort(vector&lt;int&gt; &amp;a) { int len = a.size(); for (int gap = len / 2; gap &gt; 0; gap /= 2) { for (int i = 0; i &lt; gap; i++) { for (int j = i + gap, temp, preIndex; j &lt; len; j = j + gap) //依旧需要temp作为哨兵 { temp = a[j]; //保存哨兵 preIndex = j - gap; //将要对比的编号 while (preIndex &gt;= 0 &amp;&amp; a[preIndex]&gt;temp) { a[preIndex + gap] = a[preIndex]; //被替换 preIndex -= gap; //向下走一步 } a[preIndex + gap] = temp; //恢复被替换的值 } } } } 4.3 算法分析 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 5、归并排序（Merge Sort） 5.1 算法描述 该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 代码实现 int partition(vector&lt;int&gt; &amp;a, int left, int right) { int pivot = a[right]; int i = left - 1; for (int j = left; j &lt; right; j++) { if (a[j] &lt;= pivot) { i++; swap(a[i], a[j]); } } swap(a[i + 1], a[right]); return i + 1; } void quickSort(vector&lt;int&gt; &amp;a, int left, int right) { if (left &lt; right) { int mid = partition(a, left, right); quickSort(a, left, mid - 1); quickSort(a, mid + 1, right); } } void qSort(vector&lt;int&gt; &amp;a) { quickSort(a, 0, a.size() - 1); } 5.3 算法分析 归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 6、快速排序（Quick Sort） 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 代码实现 function quickSort(arr,left,right) { int len = arr.length(), partitionIndex, left=typedef left!='number'? 0 : left, right=typedef right!='number'? len-1 : right; if(left&lt;right) { partitionIndex=partition(arr,left,right); quickSort(arr,left,partitionIndex-1); quickSort(arr,partitionIndex+1,right); } return arr; } function partition(arr,left,right) { int pivot=left, index=pivot+1; for(int i=index;i&lt;=right;i++) { if(arr[i]&gt;arr[pivot]) { swap(arr,i,index); index++; } } swap(arr,pivot,index-1); return index-1; } function swap(arr,i,j) { int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } 7、堆排序（Heap Sort） 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 代码实现 void adjustHeap(vector&lt;int&gt; &amp;a, int i,int len) { int maxIndex = i; //如果有左子树，且左子树大于父节点，则将最大指针指向左子树 if (i * 2 + 1 &lt; len &amp;&amp; a[i * 2 + 1] &gt; a[maxIndex]) maxIndex = i * 2 + 1; //如果有右子树，且右子树大于父节点和左节点，则将最大指针指向右子树 if (i * 2 + 2 &lt; len &amp;&amp; a[i * 2 + 2] &gt; a[maxIndex]) maxIndex = i * 2 + 2; //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。 if (maxIndex != i) { swap(a[maxIndex], a[i]); adjustHeap(a, maxIndex,len); } } void Sort(vector&lt;int&gt; &amp;a) { int len = a.size(); //1.构建一个最大堆 for (int i = len / 2 - 1; i &gt;= 0; i--) //从最后一个非叶子节点开始 { adjustHeap(a, i,len); } //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆 for (int i = len - 1; i &gt; 0; i--) { swap(a[0], a[i]); adjustHeap(a, 0, i); } } 8、计数排序（Counting Sort） 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 代码实现 void CountingSort(vector&lt;int&gt; &amp;a) { int len = a.size(); if (len == 0) return; int Min = a[0], Max = a[0]; for (int i = 1; i &lt; len; i++) { Max = max(Max, a[i]); Min = min(Min, a[i]); } int bias = 0 - Min; vector&lt;int&gt; bucket(Max - Min + 1, 0); for (int i = 0; i &lt; len; i++) { bucket[a[i] + bias]++; } int index = 0, i = 0; while (index &lt; len) { if (bucket[i]) { a[index] = i - bias; bucket[i]--; index++; } else i++; } } 8.3 算法分析 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 9、桶排序（Bucket Sort） 9.1 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 9.2 算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 10、基数排序（Radix Sort） 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 代码实现 void RadixSortSort(vector&lt;int&gt; &amp;a) { int len = a.size(); if (len &lt; 2) return; int Max = a[0]; for (int i = 1; i &lt; len; i++) { Max = max(Max, a[i]); } int maxDigit = log10(Max) + 1; //直接使用log10函数获取位数，这样的话就不用循环了，这里被强制转换是向下取整 int mod = 10, div = 1; vector&lt;int&gt; bucketList[10]; for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) { for (int j = 0; j &lt; len; j++) { int num = (a[j] % mod) / div; bucketList[num].push_back(a[j]); } int index = 0; for (int j = 0; j &lt; 10; j++) { int tlen=bucketList[j].size(); for (int k = 0; k &lt; tlen; k++) a[index++] = bucketList[j][k]; bucketList[j].clear(); } } } 10.3 算法分析 基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。 基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。 ","link":"https://yujieroot.github.io/post/pai-xu"},{"title":"数组的初始化与定义","content":"数组最好定义在main外： ​ 直接初始化为0 or false ​ 数组更大 1.数组大小 全局数组能开到2000020000 函数中的char数组最大能开4518028 int最大能开到518028 static能开到107*107//static和 全局开的是同一块空间 2.在main中赋值： 头文件：#include 初始化形式：memset(s(初始化数组名)，0(要替换的数字)sizeof(s))//多维数组同样 发现有时候赋值数组为0并不能得到满意的结果，但尝试用memset函数后结果正确 ","link":"https://yujieroot.github.io/post/shu-zu-de-chu-shi-hua-yu-ding-yi"},{"title":"String tips","content":"1.字符串逆转： 头文件： #include&lt;algorithm&gt; 示例：string:reverse(s.begin(),s.end()) array:reverse(a,a+len) 2.string类型的读入: cin&gt;&gt;s;//不能读入空格，以空格、制表符、回车符作为结束标志 getline(cin,s);//可以读入空格和制表符，以回车符作为结束标志 3.查找t是否为s的子串: s.find(t);//如果t是s的子串则返回首次匹配的位置，否则返回 string::npos 或 -1 4.对string类型数组排序 string s[100]; sort(s,s+n,cmp); int cmp(string a,string b) { return a&lt;b; //或a&gt;b; } 5.字符串提取 string a=s.substr(0,4); 6. 插入字符串 str1.insert(pos1,str2); str1.insert(pos1,str2,pos2,len2); str1.insert(pos1,numchar,char); //numchar是插入次数，char是要插入的字符。 7. 替换字符串 str1.replace(pos1,str2); str1.replace(pos1,str2,pos2,len2); 8. 删除字符串 str.erase(pos,len) str.clear(); 9. 交换字符串 swap(str1,str2); ","link":"https://yujieroot.github.io/post/string-tips"},{"title":"Math tips","content":"1.完全平方数的性质： 一个非完全平方数，因数个数肯定为偶数 例：8:（1,2,4,8） 一个完全平方数，因数个数肯定为奇数 例：9:（1,3,9） ","link":"https://yujieroot.github.io/post/math-tips"}]}