<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yujieroot.github.io/</id>
    <title>🎮&amp;🍺4A ブログ</title>
    <updated>2020-02-14T08:53:35.471Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yujieroot.github.io/"/>
    <link rel="self" href="https://yujieroot.github.io/atom.xml"/>
    <subtitle>root&apos;s blog</subtitle>
    <logo>https://yujieroot.github.io/images/avatar.png</logo>
    <icon>https://yujieroot.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 🎮&amp;🍺4A ブログ</rights>
    <entry>
        <title type="html"><![CDATA[穷竭搜索]]></title>
        <id>https://yujieroot.github.io/post/sou-suo</id>
        <link href="https://yujieroot.github.io/post/sou-suo">
        </link>
        <updated>2020-02-03T04:30:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="核心思想">核心思想</h1>
<blockquote>
<p>1.深度优先搜索（DFS）：从某个状态开始，不断转移，直至无法转移，回退到前一步，再继续转移到其他状态，直到找到最终解。通常采用递归函数或者栈（Stack）来实现。</p>
<p>2.宽度优先搜索（BFS）：从初始状态开始，总是先搜索至距离初始状态近的状态。每个状态都只经过一次，因此复杂度为O(状态数*转移方式数)。通常采用循环或队列（Queue）实现。</p>
</blockquote>
<h1 id="方向准备">方向准备：</h1>
<pre><code class="language-c++">int xx[]={0,0,1,-1},
	yy[]={1,-1,0,0};
</code></pre>
<pre><code class="language-c++">for(int i=0;i&lt;4;i++)
{
	int dx = x.front()+xx[i];
	int dy = y.front()+yy[i];
}
</code></pre>
<h1 id="dfs">DFS</h1>
<blockquote>
<p><strong>一共有几条路径</strong></p>
</blockquote>
<h2 id="例">例：</h2>
<h2 id="1八皇后">1.八皇后</h2>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,cnt;
bool a[20];//列
bool b[20];//右斜
bool c[40];//左斜
int s[20];

void pr()
{
	for(int i=1;i&lt;=n;i++)
    {
		cout&lt;&lt;s[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	
}
void dfs(int x)
{
	if(x&gt;n)
	{
		cnt++;
		pr();
	}
	else 
	{
		for(int i=1;i&lt;=n;i++)//行
		{
			if(!a[i]&amp;&amp;!b[x-i+n]&amp;&amp;!c[x+i])
			{
				a[i]=1;
				b[x-i+n]=1;
				c[x+i]=1;
				s[x]=i;
				dfs(x+1);
				a[i]=0;
				b[x-i+n]=0;
				c[x+i]=0; 
			}
		}
	}
}
 
int main()
{
	cin&gt;&gt;n;
	dfs(1);
	cout&lt;&lt;cnt;
}
</code></pre>
<h2 id="2迷宫">2.迷宫</h2>
<h4 id="题目背景">题目背景</h4>
<blockquote>
<p>给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。</p>
</blockquote>
<h4 id="输入格式">输入格式</h4>
<blockquote>
<p>第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。</p>
</blockquote>
<h4 id="代码">代码</h4>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,m,t,sx,sy,fx,fy,cnt;
bool vis[10][10];
bool mp[10][10];
int x[]={0,0,1,-1};
int y[]={1,-1,0,0};

void dfs(int sx,int sy)
{
	if(sx==fx&amp;&amp;sy==fy)
	{
		cnt++;
		return;
	}
	for(int i=0;i&lt;4;i++)
	{
		int dx = sx + x[i];
		int dy = sy + y[i];
		if(!vis[dx][dy]&amp;&amp;dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m&amp;&amp;!mp[dx][dy])
		{
			vis[dx][dy]=1;
			dfs(dx,dy);
			vis[dx][dy]=0;
		}
	}
}
int main()
{
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;
	while(t--)
	{
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		mp[x][y]=1;
	}
	vis[sx][sy]=1;
	dfs(sx,sy);
	cout&lt;&lt;cnt;
}
</code></pre>
<h2 id="3-shoi2002滑雪记忆化搜索">3、[SHOI2002]滑雪（记忆化搜索）</h2>
<blockquote>
<h3 id="题目描述">题目描述</h3>
<p>Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p>
<blockquote>
<pre><code>1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  12  11  10  9
</code></pre>
</blockquote>
<p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 24－17－16－1（从 24 开始，在 1 结束）。当然 25－24－23 - … - 3－2－1 更长。事实上，这是最长的一条。</p>
</blockquote>
<h4 id="代码-2">代码</h4>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};

int n,m,a[201][201],s[201][201],ans;

int dfs(int x,int y){
    if(s[x][y])return s[x][y];//记忆化搜索
    s[x][y]=1;//题目中答案是有包含这个点的
    for(int i=0;i&lt;4;i++)
    {  int xx=dx[i]+x;
       int yy=dy[i]+y;
       if(xx&gt;0&amp;&amp;yy&gt;0&amp;&amp;xx&lt;=n&amp;&amp;yy&lt;=m&amp;&amp;a[x][y]&gt;a[xx][yy]){
          dfs(xx,yy);
          s[x][y]=max(s[x][y],s[xx][yy]+1);
       }
    }
    return s[x][y];
}

int main()
{   
   scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
   for(int i=1;i&lt;=n;i++)
     for(int j=1;j&lt;=m;j++)
       scanf(&quot;%d&quot;,&amp;a[i][j]);
    for(int i=1;i&lt;=n;i++)//找从每个出发的最长距离
      for(int j=1;j&lt;=m;j++)
        ans=max(ans,dfs(i,j));//取最大值
    printf(&quot;%d&quot;,ans);
    return 0;
}
</code></pre>
<h1 id="bfs">BFS</h1>
<blockquote>
<p><strong>广搜常用于找单一的最短路线，或者是规模小的路径搜索，它的特点是&quot;搜到就是最优解&quot;</strong></p>
</blockquote>
<h2 id="例-2">例：</h2>
<h3 id="1-马的遍历">1、马的遍历</h3>
<blockquote>
<p>有一个n*m的棋盘(1&lt;n,m&lt;=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步</p>
</blockquote>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,m,sx,sy,ans;
int xx[]={1,1,-1,-1,2,2,-2,-2};
int yy[]={2,-2,2,-2,1,-1,1,-1};
struct node{
	int x;
	int y;
	int s;
};
queue&lt; node &gt; q;
int mp[405][405];

int main()
{
	memset(mp,-1,sizeof(mp));
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;sx&gt;&gt;sy;
	mp[sx][sy]=0;
	q.push((node) {sx,sy,0});
	while(!q.empty())
	{
		for(int i=0;i&lt;8;i++)
		{
			int dx=q.front().x+xx[i];
			int dy=q.front().y+yy[i];
			if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m&amp;&amp;mp[dx][dy]==-1)
			{
				mp[dx][dy]=q.front().s+1;
				q.push((node){dx,dy,q.front().s+1});
			}
		}
		q.pop();
	}
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=m;j++)
		{
			cout&lt;&lt;left&lt;&lt;setw(5)&lt;&lt;mp[i][j];
		}
		cout&lt;&lt;endl;
	}
	
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL]]></title>
        <id>https://yujieroot.github.io/post/rong-qi-shi-yong</id>
        <link href="https://yujieroot.github.io/post/rong-qi-shi-yong">
        </link>
        <updated>2020-01-31T08:51:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="万能库">万能库</h1>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
</code></pre>
<h1 id="vector">vector</h1>
<h2 id="1-定义">1、定义</h2>
<pre><code>vector&lt;类型&gt; 标识符
</code></pre>
<h2 id="2-方法">2、方法</h2>
<blockquote>
<p>1、size：返回容器中元素的数量</p>
<p>2、push_back：在容器的最后一个元素之后添加一个新元素</p>
<p>3、pop_back：删除容器中的最后一个元素，有效地将容器 size 减少一个</p>
<p>4、insert：通过在指定位置的元素<strong>之前</strong>插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小</p>
<p>5、erase：从 vector 中删除单个元素（<code>position</code>）或一系列元素（<code>[first，last)</code>），这有效地减少了被去除的元素的数量，从而破坏了容器的大小</p>
</blockquote>
<h1 id="priority_queue">priority_queue</h1>
<h2 id="1-定义-2"><strong>1、定义</strong></h2>
<blockquote>
<p>priority_queue&lt;Type, Container, Functional&gt;<br>
Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。</p>
<blockquote>
<pre><code class="language-c++">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;     
//大根
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; s;
//小根
</code></pre>
</blockquote>
</blockquote>
<blockquote>
<p>如果不写后两个参数，那么容器默认用的是vector，比较方式默认用operator&lt;，也就是优先队列是大顶堆，队头元素最大。</p>
<blockquote>
<pre><code>#include&lt;bits/stdc++.h&gt;
</code></pre>
</blockquote>
</blockquote>
<h1 id="queue">queue</h1>
<blockquote>
<p>特殊写法</p>
<blockquote>
<pre><code class="language-c++">struct node{
   int x,y,s;
};
queue&lt;node&gt; q;
int xx,yy,ss;
q.push((node){xx,yy,ss});
</code></pre>
</blockquote>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[细节]]></title>
        <id>https://yujieroot.github.io/post/za</id>
        <link href="https://yujieroot.github.io/post/za">
        </link>
        <updated>2020-01-29T07:59:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一精度问题">一，精度问题</h1>
<blockquote>
<h2 id="当题目中出现需要有高精度的输出时">当题目中出现需要有高精度的输出时：</h2>
<p>定义变量：long double<br>
scanf : %Lf<br>
pirntf : %.Lf</p>
</blockquote>
<h1 id="二输入与输出问题">二，输入与输出问题</h1>
<blockquote>
<p>除非特定情况 尽量用scanf与printf （cin，cout 容易超时😭）</p>
</blockquote>
<h2 id="1-输入">1、输入</h2>
<blockquote>
<h6 id="当需要一直输入时">当需要一直输入时：</h6>
<p>while(scanf()!=-1){}</p>
<p>while(scanf()!=EOF){}</p>
</blockquote>
<blockquote>
<h6 id="sscanf的使用">sscanf的使用：</h6>
<pre><code class="language-c++">char str[100]=&quot;2048:3.14,hello&quot;,str2[100];
sscanf(str,&quot;%d:%lf,%s&quot;,&amp;n,&amp;db,str2);//将str中的内容写入n，db，str2
printf(&quot;n=%d db=%.2f str2=%s\n&quot;,n,db,str2);
</code></pre>
<p>输出结果：</p>
<pre><code class="language-c++">n=2048 db=3.14 str2=hello
</code></pre>
</blockquote>
<h2 id="2-输出">2、输出</h2>
<blockquote>
<h6 id="sprintf的使用">sprintf的使用：</h6>
<pre><code class="language-c++">int n=12;
double db=3.1415;
char str[100],str2[100]=&quot;good&quot;;
sprintf(str,&quot;%d:%.2f,%s&quot;,n,db,str2);//将n，db，str2写入str
printf(&quot;str=%s&quot;,str);
</code></pre>
<p>输出结果：</p>
<pre><code>str=12:3.14,good
</code></pre>
</blockquote>
<blockquote>
<h6 id="输出的空格与换行">输出的空格与换行：</h6>
<pre><code class="language-c++">//末尾无换行
while(t--)
{
 cout&lt;&lt;a[t];
 if(t&gt;0) cout&lt;&lt;' ';
}
</code></pre>
<pre><code class="language-c++">//末尾无空格
for(int i=0;i&lt;n;i++)
{
 cout&lt;&lt;a[i];
 if(i&lt;n-1) cout&lt;&lt;' ';
 else cout&lt;&lt;endl;
}
</code></pre>
</blockquote>
<h1 id="三定义变量问题">三，定义变量问题</h1>
<blockquote>
<p>不加 long long 见祖宗</p>
</blockquote>
<h1 id="四-浮点数的比较">四、浮点数的比较</h1>
<blockquote>
<h6 id="1-运算符">1、== 运算符</h6>
<p>由于浮点数存储不精确，我们引入一个极小数eps来修正误差，经验表明eps取1e-8比较合适</p>
<pre><code class="language-c++">const double eps = 1e-8;
#define Equ(a,b) ((fabs((a)-(b))))&lt;(eps))
</code></pre>
<h6 id="2-运算符">2、&gt; ，&lt; 运算符</h6>
<pre><code class="language-c++">#define More(a,b) (((a)-(b))&gt;(eps))
#define Less(a,b) (((a)-(b))&lt;(-eps))
</code></pre>
<h6 id="3-运算符">3、&gt;= ,&lt;= 运算符</h6>
<pre><code>#define MoreEqu(a,b) (((a)-(b))&gt;(-eps))
#define LessEqu(a,b) (((a)-(b))&lt;(eps))
</code></pre>
<h6 id="4-圆周率">4、圆周率</h6>
<pre><code class="language-c++">const double Pi = acos(-1.0);
</code></pre>
</blockquote>
<h1 id="五-复杂度">五、复杂度</h1>
<blockquote>
<h6 id="1-时间复杂度">1、时间复杂度</h6>
<p>对一般oj，1s能承受的运算次数大概是1e7~1e8</p>
<h6 id="2-空间复杂度">2、空间复杂度</h6>
<p>二维数组的复杂度：O(n^2)</p>
<p>只要不开好几个10^7以上的数组即可</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[十大经典排序算法]]></title>
        <id>https://yujieroot.github.io/post/pai-xu</id>
        <link href="https://yujieroot.github.io/post/pai-xu">
        </link>
        <updated>2020-01-22T07:31:44.000Z</updated>
        <content type="html"><![CDATA[<p>​    1.冒泡排序</p>
<p>​    2.选择排序</p>
<p>​    3.插入排序</p>
<p>​    //若无限制可随意用</p>
<p>​    4.希尔排序</p>
<p>​    5.归并排序</p>
<p>​    6.快速排序</p>
<p>​    7.堆排序</p>
<p>​    8  .计数排序</p>
<p>​    9.桶排序</p>
<p>​    10.基数排序</p>
<h2 id="时间复杂度"><strong>时间复杂度:</strong></h2>
<ul>
<li>平方阶O(n2)排序，各类简单排序：插入、选择和冒泡排序；</li>
<li>线性对数阶O(nlog2n)排序：快速排序、堆排序和归并排序；</li>
<li>O(n+§)排序，§是介于0和1之间的常数：希尔排序；</li>
<li>线性阶O(n)排序：基数排序，桶、箱排序；</li>
</ul>
<p><img src="https://yujieroot.github.io//post-images/1579770003336.png" alt="" loading="lazy"><img src="D:%5Cimage%5Csort.png" alt="" loading="lazy"></p>
<h2 id="1冒泡排序"><strong>1.冒泡排序</strong></h2>
<h3 id="11算法描述">1.1算法描述</h3>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在<strong>最后的元素应该会是最大的数；</strong></li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<h3 id="12代码实现">1.2代码实现</h3>
<pre><code class="language-c++">for(int i=0;i&lt;len-1;i++)
{
    for(int j=0;j&lt;len-1-i;j++)
    {
        if(a[j]&gt;a[j+1])
        {
            swap(a[i],a[j]);
        }
    }
}
</code></pre>
<h2 id="2选择排序">2.选择排序</h2>
<h3 id="21算法描述">2.1算法描述</h3>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h3 id="22代码实现">2.2代码实现</h3>
<pre><code class="language-c++">for(int i=0;i&lt;len-1;i++)
{
    int max=i;
    for(int j=i+1;j&lt;len;j++)
    {
        if(a[max]&lt;a[j])
        {
            max=j;
        }
    }
    temp=arr[i];
    arr[i]=a[max];
    a[max]=temp;
}
</code></pre>
<h3 id="23算法分析">2.3算法分析</h3>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="3-插入排序">3、插入排序</h2>
<h3 id="31算法描述">3.1算法描述</h3>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<h3 id="32-代码实现">3.2 代码实现</h3>
<pre><code class="language-c++">for(int i=1;i&lt;len;i++)
{
    preIndex=i-1;
    current=a[i];
    while(preIndex&gt;=0;&amp;&amp;a[preIndex]&gt;a[i])
    {
        a[i]=a[preIndex];
        preIndex--;
    }//a[i]永远是preIndex及其以前数据中最大的
    a[preIndex+1]=current;
}
</code></pre>
<h3 id="33-算法分析">3.3 算法分析</h3>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h2 id="4-希尔排序shell-sort">4、希尔排序（Shell Sort）</h2>
<h3 id="41-算法描述">4.1 算法描述</h3>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h3 id="42-代码实现">4.2 代码实现</h3>
<pre><code class="language-c++">void shell_Sort(vector&lt;int&gt; &amp;a)
{
    int len = a.size();
    for (int gap = len / 2; gap &gt; 0; gap /= 2)
    {
        for (int i = 0; i &lt; gap; i++)
        {
            for (int j = i + gap, temp, preIndex; j &lt; len; j = j + gap) //依旧需要temp作为哨兵
            {
                temp = a[j];        //保存哨兵
                preIndex = j - gap; //将要对比的编号
                while (preIndex &gt;= 0 &amp;&amp; a[preIndex]&gt;temp)
                    {
                        a[preIndex + gap] = a[preIndex]; //被替换
                        preIndex -= gap;                 //向下走一步
                    }
                a[preIndex + gap] = temp; //恢复被替换的值
            }
        }
    }
}
</code></pre>
<h3 id="43-算法分析">4.3 算法分析</h3>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<h2 id="5-归并排序merge-sort">5、归并排序（Merge Sort）</h2>
<h3 id="51-算法描述">5.1 算法描述</h3>
<p>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<h3 id="52-代码实现">5.2 代码实现</h3>
<pre><code class="language-c++">int partition(vector&lt;int&gt; &amp;a, int left, int right)
{
    int pivot = a[right];
    int i = left - 1;
    for (int j = left; j &lt; right; j++)
    {
        if (a[j] &lt;= pivot)
        {
            i++;
            swap(a[i], a[j]);
        }
    }
    swap(a[i + 1], a[right]);
    return i + 1;
}

void quickSort(vector&lt;int&gt; &amp;a, int left, int right)
{
    if (left &lt; right)
    {
        int mid = partition(a, left, right);
        quickSort(a, left, mid - 1);
        quickSort(a, mid + 1, right);
    }
}

void qSort(vector&lt;int&gt; &amp;a)
{
    quickSort(a, 0, a.size() - 1);
}
</code></pre>
<h3 id="53-算法分析">5.3 算法分析</h3>
<p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<strong>O(nlogn）的时间复杂度</strong>。代价是<strong>需要额外的内存空间。</strong></p>
<h2 id="6-快速排序quick-sort">6、快速排序（Quick Sort）</h2>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h3 id="61-算法描述">6.1 算法描述</h3>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>
<p>从数列中挑出一个元素，称为 “基准”（pivot）；</p>
</li>
<li>
<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li>
<p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ul>
<h3 id="62-代码实现">6.2 代码实现</h3>
<pre><code class="language-c++">function quickSort(arr,left,right)
{
	int len = arr.length(),
    	partitionIndex,
    	left=typedef left!='number'? 0 : left,
    	right=typedef right!='number'? len-1 : right;
    if(left&lt;right)
    {
        partitionIndex=partition(arr,left,right);
        quickSort(arr,left,partitionIndex-1);
        quickSort(arr,partitionIndex+1,right);
    }
    return arr;
}
function partition(arr,left,right)
{
    int pivot=left,
    	index=pivot+1;
    for(int i=index;i&lt;=right;i++)
    {
        if(arr[i]&gt;arr[pivot])
        {
            swap(arr,i,index);
            index++;
        }
    }
    swap(arr,pivot,index-1);
    return index-1;
}
function swap(arr,i,j)
{
    int temp=arr[i];
    arr[i]=arr[j];
    arr[j]=temp;
}
</code></pre>
<h2 id="7-堆排序heap-sort">7、堆排序（Heap Sort）</h2>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h3 id="71-算法描述">7.1 算法描述</h3>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<h3 id="72-代码实现">7.2 代码实现</h3>
<pre><code class="language-c++c">void adjustHeap(vector&lt;int&gt; &amp;a, int i,int len)
{
    int maxIndex = i;
    //如果有左子树，且左子树大于父节点，则将最大指针指向左子树
    if (i * 2 + 1 &lt; len &amp;&amp; a[i * 2 + 1] &gt; a[maxIndex])
        maxIndex = i * 2 + 1;
    //如果有右子树，且右子树大于父节点和左节点，则将最大指针指向右子树
    if (i * 2 + 2 &lt; len &amp;&amp; a[i * 2 + 2] &gt; a[maxIndex])
        maxIndex = i * 2 + 2;
    //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。
    if (maxIndex != i)
    {
        swap(a[maxIndex], a[i]);
        adjustHeap(a, maxIndex,len);
    }
}

void Sort(vector&lt;int&gt; &amp;a)
{
    int len = a.size();
    //1.构建一个最大堆
    for (int i = len / 2 - 1; i &gt;= 0; i--) //从最后一个非叶子节点开始
    {
        adjustHeap(a, i,len);
    }
    //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆

    for (int i = len - 1; i &gt; 0; i--)
    {
        swap(a[0], a[i]);
        adjustHeap(a, 0, i);
    }
}
</code></pre>
<h2 id="8-计数排序counting-sort">8、计数排序（Counting Sort）</h2>
<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h3 id="81-算法描述">8.1 算法描述</h3>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<h3 id="82-代码实现">8.2 代码实现</h3>
<pre><code class="language-c++">void CountingSort(vector&lt;int&gt; &amp;a)
{
    int len = a.size();
    if (len == 0)
        return;
    int Min = a[0], Max = a[0];
    for (int i = 1; i &lt; len; i++)
    {
        Max = max(Max, a[i]);
        Min = min(Min, a[i]);
    }
    int bias = 0 - Min;
    vector&lt;int&gt; bucket(Max - Min + 1, 0);
    for (int i = 0; i &lt; len; i++)
    {
        bucket[a[i] + bias]++;
    }
    int index = 0, i = 0;
    while (index &lt; len)
    {
        if (bucket[i])
        {
            a[index] = i - bias;
            bucket[i]--;
            index++;
        }
        else
            i++;
    }
}
</code></pre>
<h3 id="83-算法分析">8.3 算法分析</h3>
<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h2 id="9-桶排序bucket-sort">9、桶排序（Bucket Sort）</h2>
<h3 id="91-算法描述">9.1 算法描述</h3>
<ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ul>
<h3 id="92-算法分析">9.2 算法分析</h3>
<p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
<h2 id="10-基数排序radix-sort">10、基数排序（Radix Sort）</h2>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<h3 id="101-算法描述">10.1 算法描述</h3>
<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<h3 id="102-代码实现">10.2 代码实现</h3>
<pre><code class="language-c++">void RadixSortSort(vector&lt;int&gt; &amp;a)
{
    int len = a.size();
    if (len &lt; 2)
        return;
    int Max = a[0];
    for (int i = 1; i &lt; len; i++)
    {
        Max = max(Max, a[i]);
    }
    int maxDigit = log10(Max) + 1;
    //直接使用log10函数获取位数，这样的话就不用循环了，这里被强制转换是向下取整
    int mod = 10, div = 1;
    vector&lt;int&gt; bucketList[10];
    for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10)
    {
        for (int j = 0; j &lt; len; j++)
        {
            int num = (a[j] % mod) / div;
            bucketList[num].push_back(a[j]);
        }
        int index = 0;
        for (int j = 0; j &lt; 10; j++)
        {
            int tlen=bucketList[j].size();
            for (int k = 0; k &lt; tlen; k++)
                a[index++] = bucketList[j][k];
            bucketList[j].clear();
        }
    }
}
</code></pre>
<h3 id="103-算法分析">10.3 算法分析</h3>
<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。<br>
基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组]]></title>
        <id>https://yujieroot.github.io/post/shu-zu-de-chu-shi-hua-yu-ding-yi</id>
        <link href="https://yujieroot.github.io/post/shu-zu-de-chu-shi-hua-yu-ding-yi">
        </link>
        <updated>2020-01-22T07:27:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数组最好定义在main外"><strong>数组最好定义在main外：</strong></h1>
<ol>
<li><strong>直接初始化为0 or false</strong></li>
<li><strong>数组更大</strong></li>
</ol>
<h2 id="1数组大小"><strong>1.数组大小</strong></h2>
<ul>
<li>全局数组能开到20000<em>20000</em></li>
<li><em>函数中的char数组最大能开4</em>518028</li>
<li>int最大能开到518028</li>
<li>static能开到107*107//static和 全局开的是同一块空间</li>
</ul>
<h2 id="2赋值"><strong>2.赋值：</strong></h2>
<blockquote>
<p>对数组中的每一个元素赋相同的值：</p>
<pre><code class="language-c++">memset(数组名，值，sizeof(数组名))；
</code></pre>
<p><strong>只用来赋值 0或-1</strong></p>
<p>若要赋其他的值，用fill函数（memset更快）</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[String tips]]></title>
        <id>https://yujieroot.github.io/post/string-tips</id>
        <link href="https://yujieroot.github.io/post/string-tips">
        </link>
        <updated>2020-01-22T07:13:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1字符串逆转">1.字符串逆转：</h1>
<pre><code class="language-c++">示例：string:reverse(s.begin(),s.end())  
     array:reverse(a,a+len)
</code></pre>
<h1 id="2-string类型的读入">2. string类型的读入:</h1>
<pre><code class="language-c++"> cin&gt;&gt;s;//不能读入空格，以空格、制表符、回车符作为结束标志
 getline(cin,s);//可以读入空格和制表符，以回车符作为结束标志
</code></pre>
<h1 id="3查找t是否为s的子串">3.查找t是否为s的子串:</h1>
<pre><code>s.find(t);//如果t是s的子串则返回首次匹配的位置，否则返回 string::npos 或 -1
</code></pre>
<h1 id="4比较两个字符串">4.比较两个字符串</h1>
<pre><code class="language-c++">strcmp(s1,s2)//按字典序，if(s1&lt;s2 return &lt;0)，if(s1==s2 return 0),if(s1&gt;s2 return &gt;0)
</code></pre>
<h1 id="5字符串提取">5.字符串提取</h1>
<pre><code class="language-c++">string a=s.substr(0,4);
</code></pre>
<h1 id="6-插入字符串">6. 插入字符串</h1>
<pre><code class="language-c++">str1.insert(pos1,str2);
str1.insert(pos1,str2,pos2,len2);
str1.insert(pos1,numchar,char); //numchar是插入次数，char是要插入的字符。
</code></pre>
<h1 id="7-替换字符串">7. 替换字符串</h1>
<pre><code class="language-c++">str1.replace(pos1,str2);
str1.replace(pos1,str2,pos2,len2);
</code></pre>
<h1 id="8-删除字符串">8. 删除字符串</h1>
<pre><code class="language-c++">str.erase(pos,len)
str.clear();
</code></pre>
<h1 id="9-交换字符串">9. 交换字符串</h1>
<pre><code class="language-c++">swap(str1,str2);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math tips]]></title>
        <id>https://yujieroot.github.io/post/math-tips</id>
        <link href="https://yujieroot.github.io/post/math-tips">
        </link>
        <updated>2020-01-22T06:50:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="常用的math函数">常用的math函数</h1>
<blockquote>
<p>1.fabs（double x） abs(int x)</p>
<p>2.floor(double x)      ceil(double x) //向下取整（取小）    向上取整（取大）</p>
<p>3.pow(double r,double p)</p>
<p>4.round(double x) //将x变量四舍五入  返回类型也是double</p>
</blockquote>
<h1 id="完全平方数的性质">完全平方数的性质：</h1>
<blockquote>
<p>一个非完全平方数，因数个数肯定为偶数 例：8:（1,2,4,8）<br>
一个完全平方数，因数个数肯定为奇数 例：9:（1,3,9）</p>
</blockquote>
<h1 id="余数的规律">余数的规律</h1>
<blockquote>
<h2 id="例">例：</h2>
<blockquote>
<p>b=2,p=10 k=9</p>
<p>2^1=2 2%9=2</p>
<p>2^2=4 4%9=4</p>
<p>2^3=8 8%9=8</p>
<p>2^4=16 16%9=7</p>
<p>2^5=32 32%9=5</p>
<p>2^6=64 64%9=1</p>
<p>2^7=128 128%9=2</p>
</blockquote>
<p>我们会发现，余数到2<sup>7的时候就已经跟2</sup>1重复了 每一个数都是一样的</p>
</blockquote>
<h2 id="代码">代码</h2>
<pre><code class="language-c++">long long a,b,c;
long s=a%c;
long t=1;
for(int i=2;i&lt;=b;i++)
{
	s=s*a%c;
    if(s==a%c) break;
    t++;
}
b%=t;
if(b==0) b=t;
s=1;
for(int i=1;i&lt;=b;i++)
{
    s=s*a%c;
}
//s即为a的b次方除c的余数
</code></pre>
<h1 id=""></h1>
]]></content>
    </entry>
</feed>